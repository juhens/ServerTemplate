// <auto-generated> 
// THIS CODE IS AUTOMATICALLY GENERATED. DO NOT EDIT. 
// </auto-generated>
#nullable enable
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ServerCore.Packet;

namespace PacketGen
{
    public static class PacketManager
    {
        private static class PacketWrapper<T> where T : IPacket
        {
            public static Action<PacketSession, T>? Handler;
        }

        private static readonly Dictionary<ProtocolId, Action<PacketSession, ArraySegment<byte>>> OnRecv = new();

        static PacketManager()
        {
            PacketWrapper<S_HandshakeSynAck>.Handler = PacketHandler.S_HandshakeSynAck_Handler;
            OnRecv.Add(ProtocolId.S_HandshakeSynAck, MakePacket<S_HandshakeSynAck>);
            PacketWrapper<S_LoginResponse>.Handler = PacketHandler.S_LoginResponse_Handler;
            OnRecv.Add(ProtocolId.S_LoginResponse, MakePacket<S_LoginResponse>);
            PacketWrapper<S_WorldInfoArray>.Handler = PacketHandler.S_WorldInfoArray_Handler;
            OnRecv.Add(ProtocolId.S_WorldInfoArray, MakePacket<S_WorldInfoArray>);
            PacketWrapper<S_PlayerInfoArray>.Handler = PacketHandler.S_PlayerInfoArray_Handler;
            OnRecv.Add(ProtocolId.S_PlayerInfoArray, MakePacket<S_PlayerInfoArray>);
            PacketWrapper<S_EnterZoneResult>.Handler = PacketHandler.S_EnterZoneResult_Handler;
            OnRecv.Add(ProtocolId.S_EnterZoneResult, MakePacket<S_EnterZoneResult>);
            PacketWrapper<S_SystemMessage>.Handler = PacketHandler.S_SystemMessage_Handler;
            OnRecv.Add(ProtocolId.S_SystemMessage, MakePacket<S_SystemMessage>);
            PacketWrapper<S_Chat>.Handler = PacketHandler.S_Chat_Handler;
            OnRecv.Add(ProtocolId.S_Chat, MakePacket<S_Chat>);
        }

        public static void OnRecvPacket(PacketSession session, uint protocolId, ArraySegment<byte> payloadBuffer)
        {
            if (OnRecv.TryGetValue((ProtocolId)protocolId, out var action))
            {
                action.Invoke(session, payloadBuffer);
            }
            else
            {
                session.Disconnect($"Bad ProtocolId:{protocolId}");
            }
        }

        private static void MakePacket<T>(PacketSession session, ArraySegment<byte> buffer) where T : IPacket, IStruct, new()
        {
            var reader = new PacketReader(buffer);
            var packet = new T();
            packet.Deserialize(ref reader);

            PacketWrapper<T>.Handler?.Invoke(session, packet);
        }
    }
}
